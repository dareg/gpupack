.TH mpsh 1
.\" Automatically generated by Pod::Man version 1.15
.\" Fri Apr 21 09:56:14 2006
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "MPSH 1"
.TH MPSH 1 "perl v5.6.1" "2005-09-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
.Vb 1
\&  MPSH, MPSH_REGION, MPSH_SINGLE, MPSH_OUTPUT, MPSH_CLEAN
.Ve
.Vb 1
\&  message passing shell toolbox
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  MPSH_REGION << 'MPSH_END'
\&    echo part 1
\&  MPSH_SECTION
\&    echo another part
\&  MPSH_SECTION
\&    echo number $MPSH_SECTION
\&  MPSH_END
.Ve
.Vb 1
\&  ...
.Ve
.Vb 1
\&  MPSH_SINGLE echo "oups... forgot this one !"
.Ve
.Vb 1
\&  ...
.Ve
.Vb 1
\&  MPSH
.Ve
.Vb 1
\&  MPSH_OUTPUT
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`mpsh\*(C'\fR set of commands defines sections of shell scripts to be
executed simultaneously by different processors in a \fBbatch environement\fR.
Therefore these chunks of shell must be independent and should not defined
environment variables that other parts of the shell could rely on.
.PP
The definition of such sections is done through a \fIhere document\fR
given to \fB\s-1MPSH_REGION\s0\fR or through a \fB\s-1MPSH_SINGLE\s0\fR instruction.
.PP
The parallel execution itself is achived by calling \fB\s-1MPSH\s0\fR.
.PP
Ordered outputs could be displayed through the \fB\s-1MPSH_OUTPUT\s0\fR command.
.PP
Before calling \fB\s-1MPSH\s0\fR, any number of \fB\s-1MPSH_SINGLE\s0\fR or \fB\s-1MPSH_REGION\s0\fR
could occured, using the \fIadd\fR mode of the \fB\s-1MPSH_REGION\s0\fR command :
.PP
.Vb 3
\&  MPSH_REGION mode:add << MPSH_END
\&    echo push this part to any existing job sequence if any
\&  MPSH_END
.Ve
The \fB\s-1MPSH_SINGLE\s0\fR is always in the \fIadd\fR mode.
.PP
If some chunks of shell absolutly need to run together (but this information
is not available when writing the script for example in automatic shell
generation), then one could used the tagging mechanism to achieve such behavior:
.PP
.Vb 9
\&  MPSH_REGION << MPSH_END
\&    echo first part
\&  MPSH_SECTION tag:coolpart
\&    echo here is the cool part
\&  MPSH_SECTION
\&    echo something else to do ?
\&  MPSH_SECTION tag:coolpart
\&    echo pleeeease, I wanna be cool !
\&  MPSH_END
.Ve
In that case, only 3 jobs will be created (and not 4).
.PP
Options are cumulative and one could write :
.PP
.Vb 3
\&  MPSH_REGION mode:add tag:fun << MPSH_END
\&  ...
\&  MPSH_END
.Ve
Four environment variables are exported in each chunk of shell :
\&\fB\s-1MPSH_SECTION\s0\fR which is the number of the current job,
\&\fB\s-1MPSH_JOBS\s0\fR which is the total number of jobs to proceed,
\&\fB\s-1MPSH_NPES\s0\fR which is the total number of processing elements,
\&\fB\s-1MPSH_PEID\s0\fR which is the current processing element id (machine dependent).
.PP
Note that if \fB\s-1MPSH_REGION\s0\fR command is used whith a single sequence
of code ( no \fB\s-1MPSH_SECTION\s0\fR inside the here document ), and \fIall\fR
mode is activated, then this sequence of shell is duplicated
for each processor, unless the \fIadd\fR mode is specified :
.PP
.Vb 4
\&  MPSH_REGION mode:all << 'MPSH_END'
\&    echo each proc should execute my shell task
\&    my_task.sh $MPSH_SECTION
\&  MPSH_END
.Ve
Another feature of the \fB\s-1MPSH_REGION\s0\fR or \fB\s-1MPSH_SECTION\s0\fR
command is the loop mechanism :
.PP
.Vb 3
\&  MPSH_REGION loop:001-008-2,foo,bar << 'MPSH_END'
\&    echo this is loop index $MPSH_INDEX
\&  MPSH_END
.Ve
\&... will produce 6 iterations, with associated indexes \*(L"001\*(R", \*(L"003\*(R",
\&\*(L"005\*(R", \*(L"007\*(R", \*(L"foo\*(R" and \*(L"bar\*(R".
.PP
\&\s-1MPSH\s0 command are self-protected, ie : \s-1MPSH_REGION\s0 is ignored inside
an other \s-1MPSH_REGION\s0 ( as well as matching MPSH_SECTIONs ).
.PP
The estimate overhead of using mpsh is 2 seconds...
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See \fI/usr/local/mpsh/examples\fR directory.
.SH "FILES"
.IX Header "FILES"
/usr/local/mpsh/bin
  Path to add to the \s-1PATH\s0 variable.
.PP
/usr/local/mpsh/examples
  Some examples for each functionality of the toolbox.
.SH "AUTHOR"
.IX Header "AUTHOR"
eric.sevault@meteo.fr ( \s-1CNRM/GMAP/ALGO\s0 \- 84 71 )
.PP
many thanks to :
  pascal.lamboley@meteo.fr ( \s-1DP/PREVI/COMPAS\s0 )
  ryad.elkhatib@meteo.fr( \s-1CNRM/GMAP/ALGO\s0 ).
